<<<<<<< HEAD
# 길이가 N인 컨베이어 벨트가 있고,
# 길이가 2N인 벨트가 이 컨베이어 벨트를 위아래로 감싸며 돌고 있다
# 1~2N 번호
# 회전하면 1씩 움직인다
# i번 칸의 내구도는 Ai이다 
# 1번칸의 위치는 올리는 위치, N번칸의 위치를 내리는 위치
# 로봇이 어떤 칸으로 이동하면 그 칸의 내구도는 즉시 1만큼 감소한다

# 내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료한다.
# 그렇지 않다면 1번으로 돌아간다.

# 2<= N <= 100, 1<= K <=2N
n,k = map(int,input().split())
# 1<= A <= 1000
a = list(map(int,input().strip().split()))

start, end = 0,len(a)//2-1

print(a)
=======
# 1부터 N까지 양의 정수를 언소로 갖는 집합

# 이 집합의 모든 부분 집합에 대해 원소의 합이 K인 경우의 수 M을 알아내려고한다

# 부분 집합의 개수 2^N개이기 때문에 모든 부분 집합을 만들어 확인하려면 시간이 오래 걸리지만,
# 정수 i를 부분집합에 포함시킬지 고려할 때 이미 부분집합에 포함시킨 원소의 합 S와
# 아직 고려하지 않은 숫자들의 합 R을 동시에 활용하면 시간을 단축할 수 있다고 한다

# 이를 활용해 M을 출력하는 프로그램을 작성하시오.
>>>>>>> d76f0586adb5eb7174a8c4f34fa4516685a71558
